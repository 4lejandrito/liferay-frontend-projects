# Dependency confusion attacks

## What are dependency confusion attacks?

[Dependency confusion attacks](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610) may arise when we create and consume an _unpublished_ npm package from inside one of our code bases, or on one of our machines, or one of our customers' machines etc. The following example illustrates the concept:

> We create an unpublished npm package (a directory with a `package.json` file containing a `name` property) because we want a way of organizing our JS code into modules. Let's say we name the package `frontend-js-web` and our intention is to:
>
> 1. Consume it internally within [the liferay-portal codebase](https://github.com/liferay/liferay-portal), for example, with statements such as `import something from 'frontend-js-web';` and [the Yarn workspace mechanism](https://classic.yarnpkg.com/en/docs/workspaces/), using a dependency on `frontend-js-web` declared in our `package.json` files.
> 2. Never actually _publish_ the package with the npm registry.
> 3. Never attempt to _download_ the package from the npm registry, because we have the code locally (see point "1").
>
> Nevertheless, if there is a `package.json` file somewhere on a network that declares a dependency on `frontend-js-web`, it is conceivable that a combination of conditions could arise that lead to potentially malicious third-party code to be downloaded onto a system and executed. The most straightforward example would simply be copying a `package.json` file into an arbitrary location and running `npm install`; unless there is something in place to prevent it (such as a registry proxy, or a workspace configuration that would cause the package to be resolved locally), the `npm` client will connect to the internet and attempt to download the package from the npm registry. If a third party has registered the package, it will be downloaded. The user who ran the code may expect `frontend-js-web` to contain Liferay's code, but if an attacker has registered a package under that name, then it will be their code that runs instead. A common tactic that is employed when a package is taken over in a hostile fashion like this is to use [a "preinstall" script](https://docs.npmjs.com/cli/v7/using-npm/scripts) that will run code bundled inside the package as soon as it is installed (it is not even necessary to use the package or run the software that uses the package). The "preinstall" script could "phone home", exfiltrate information from the user's system, destroy data, or pursue any of a number of nefarious ends.

While the above example is set in liferay-portal, you can imagine similar scenarios inside Workspaces or literally any _other context in which a user does anything with npm_. In some ways this is a subtle problem, but the essence is that _any usage of unpublished npm packages is potentially dangerous_.

In practice, attackers can find out interesting package names to appropriate via active search (for example, searching in open source code repositories, or inspecting network traffic to see what module names a DXP instance is using), or by simply guessing (for example, given a common prefix like `liferay-`, an attacker could preemptively register a large number of package names that they deem to be likely candidates for future use).

## How do we mitigate dependency confusion attacks?

There are two very obvious ways to stop a dependency confusion attack before it even starts:

1. **Register an npm package for any `name` that you wish to use, before you use it.** To register an npm package you just [publish it](https://docs.npmjs.com/cli/v7/commands/npm-publish); if the name is available it's yours forever and an attacker will never be able to substitute it with a malicious package of their own.
2. **Name your package inside [a "named scope"](https://docs.npmjs.com/cli/v7/using-npm/scope).** A named scope corresponds to an npm user and only that user may publish packages inside the scope. For example, `@liferay/frontend-js-web` is a package inside the `@liferay` named scope.

Some things to note about these strategies:

-   It is good practice to go back and retrospectively register packages to cover names that have been used historically in the past (eg. `frontend-js-web`). We have done this for some 200 odd packages across all branches of Liferay DXP.
-   These packages don't even need to contain the source code of the corresponding module in liferay-portal. They can be placeholder packages like [`frontend-taglib`](https://www.npmjs.com/package/frontend-taglib) which show a notice saying on the registry page and at install time: "This package is not intended to be consumed directly; please see...".
-   When using the "named scope" technique, you don't even need to publish a placeholder package; the mere fact of the package name falling inside a scope means that only you could ever publish it; that door is closed to attackers.
-   Note that in order for the "named scope" technique to be effective, you _do_ have to have exclusive control over the npm user that owns the scope; it is not sufficient to name your package under `@somerandomscope` and expect it to be protected.
-   The "named scope" technique can be used in broader contexts outside of liferay-portal by selecting an appropriate npm user. While we use the `@liferay` named scope inside liferay-portal itself, in a customer or partner project it is appropriate to use a scope like `@somecustomer`, `@somepartner` or `@someproject` (again, note that, to be effective, you or the customer _do_ need to control that npm user, so the choice is not entirely arbitrary). This repo itself contains an _unpublished_ `@liferay/workspace-scripts` package that is used internally, following [the "named scope" pattern](https://github.com/liferay/liferay-frontend-projects/blob/3a664d7ace9cb56d3134439d9ef74327c6da6a17/support/packages/workspace-scripts/package.json#L8).
-   When employing either of these techniques, it is important to follow standard best practices as we would for any software that we produce in service of the corporation. That means, for example, that packages should be published using shared credentials that are securely stored using a company-sponsored password management system, and they shouldn't be published using personal accounts. As an example, we registered the 200 or so legacy placeholder packages mentioned above using the `liferay` NPM user controlled by the Frontend Infrastructure team. Likewise, when we publish new packages under the `@liferay` named scope, those correspond to the official `liferay` user.
-   Note that marking a package as `"private": true` does nothing to mitigate a dependency confusion attack; if a package is indeed marked private but is not published, then a victim running `npm install` in the wrong context will still find their machine connecting to the registry and attempting a download if such a package exists.

## How likely are dependency confusion attacks?

In day-to-day practice, dependency confusion attacks are relatively unlikely in the context of liferay-portal for these reasons:

-   Our [Yarn workspace configuration](https://github.com/liferay/liferay-portal/blob/86ede804ce42ff073f9e2dc1df708a8945cdeaad/modules/package.json#L17-L25) is very simple and broad. As long as we put our modules in the "standard" locations defined by these globs, these packages automatically participate in the Yarn workspace mechanism, which means that Yarn commands will always chose the local versions of referenced packages and not attempt to download them over the network.
-   Our Yarn and npm operations are abstracted away inside Gradle tasks which mean that developers shouldn't be running npm commands directly in any case.
-   At the time of writing, we have claimed all historically active npm package names used on all branches of DXP, we have began to migrate existing names (for example, `frontend-js-react-web` is [now named `@liferay/frontend-js-react-web`](https://github.com/liferay/liferay-portal/blob/86ede804ce42ff073f9e2dc1df708a8945cdeaad/modules/apps/frontend-js/frontend-js-react-web/package.json#L17)), and the overall status of the migration can be tracked in [LPS-129670](https://issues.liferay.com/browse/LPS-129670). Additionally, as of [#500](https://github.com/liferay/liferay-frontend-projects/pull/500) (released in [@liferay/npm-scripts v44.0.0](https://github.com/liferay/liferay-frontend-projects/releases/tag/npm-scripts%2Fv44.0.0)), we have added a lint to prevent non-scoped packages from being added.
-   Actually triggering an attack requires both an attacker to register an unpublished package name that we are using internally _and_ a user has to carry out an unlikely series of actions in order to trigger a download (for example, stepping outside the normal Gradle-managed workflow, copy-pasting dependency names into other contexts, and manually running a command like `npm install`).

Nevertheless "unlikely" does not equate to "safety" in the context of a hostile environment, so the Frontend Infrastructure team is going to continue investing in the mitigations described above, and strongly recommends that other teams do the same in their contexts. Please [file an issue](https://github.com/liferay/liferay-frontend-projects/issues/new/choose) with us or reach out to us on the team Slack channel ([`#t-frontend-infra`](https://liferay.slack.com/archives/CNBG06JS3)) if you have any questions, or run into problems with tooling that may not yet be equipped to properly handle named scope package names.
