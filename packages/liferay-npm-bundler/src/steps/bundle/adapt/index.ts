/**
 * SPDX-FileCopyrightText: Â© 2020 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

import fs from 'fs-extra';
import {addNamespace} from 'liferay-js-toolkit-core';

import {bundlerWebpackDir, project} from '../../../globals';
import * as log from '../../../log';
import {render, transformFile} from './util';
import wrapBundles from './wrap-bundles';
import writeExportModules from './write-export-modules';

export default async function adapt(): Promise<void> {
	copyWebpackBundles();
	await writeManifestModule();
	await writeExportModules();
	await internalizeWebpackManifest();
	await wrapBundles();
	await injectImportsInPkgJson();
}

/**
 * Copy bundles generated by webpack from webpack's output dir to bundler's.
 */
function copyWebpackBundles(): void {
	['runtime', 'vendor', ...Object.keys(project.exports)].forEach((id) => {
		const fileName = `${id}.bundle.js`;

		const sourceFile = bundlerWebpackDir.join(fileName);
		const destFile = project.outputDir.join(fileName);

		// TODO: copy map files

		if (fs.existsSync(sourceFile.asNative)) {
			fs.copyFileSync(sourceFile.asNative, destFile.asNative);
		} else {
			fs.writeFileSync(destFile.asNative, '');
		}

		log.debug(`Copied ${fileName} to output directory`);
	});
}

async function injectImportsInPkgJson(): Promise<void> {
	const file = project.outputDir.join('package.json');

	const pkgJson = fs.readJSONSync(file.asNative);

	const {imports} = project;

	pkgJson.dependencies = {
		...pkgJson.dependencies,
		...Object.entries(imports).reduce((deps, [pkgName, config]) => {
			const {provider, version} = config;

			const namespacedPkgName = addNamespace(pkgName, {
				name: provider,
			});

			// Make sure we don't use our local copy but the imported one
			delete deps[pkgName];
			deps[namespacedPkgName] = version;

			return deps;
		}, {}),
	};

	fs.writeFileSync(file.asNative, JSON.stringify(pkgJson, null, '\t'));
}

/**
 * Internalize webpack manifest object (`window["webpackJsonp"]`) so that it is
 * contained in our generated AMD manifest module instead of polluting `window`
 */
async function internalizeWebpackManifest(): Promise<void> {
	// TODO: update map files

	const transform = (content: string): string =>
		content.replace(/window\["webpackJsonp"\]/g, '__WEBPACK_MANIFEST__');

	await Promise.all(
		['runtime', 'vendor', ...Object.keys(project.exports)].map(
			async (id) => {
				const fileName = `${id}.bundle.js`;

				await transformFile(fileName, transform);

				log.debug(`Internalized webpack manifest of ${fileName}`);
			}
		)
	);
}

/**
 * Generates an AMD module to hold webpack manifest so that it is not placed in
 * `window["webpackJsonp"]`
 */
async function writeManifestModule(): Promise<void> {
	const {name, version} = project.pkgJson;
	const moduleName = `${name}@${version}/webpack.manifest`;

	fs.writeFileSync(
		project.outputDir.join(`webpack.manifest.js`).asNative,
		await render('manifest-module', {moduleName})
	);

	log.debug(`Generated AMD module to hold webpack manifest`);
}
