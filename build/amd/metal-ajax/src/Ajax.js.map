{"version":3,"sources":["Ajax.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCAmCkB,KAAK;AAAL,SAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAqIrB,IAAI","file":"bower_components/metal-ajax/src/Ajax.js","sourcesContent":["'use strict';\n\nimport core from 'bower:metal/src/core';\nimport { CancellablePromise as Promise } from 'bower:metal-promise/src/promise/Promise';\n\nclass Ajax {\n\n\t/**\n\t * Adds parameters into the url querystring.\n\t * @param {string} url\n\t * @param {MultiMap} opt_params\n\t * @return {string} Url containting parameters as querystring.\n\t * @protected\n\t */\n\tstatic addParametersToUrlQueryString(url, opt_params) {\n\t\tvar querystring = '';\n\t\topt_params.names().forEach(function(name) {\n\t\t\topt_params.getAll(name).forEach(function(value) {\n\t\t\t\tquerystring += name + '=' + encodeURIComponent(value) + '&';\n\t\t\t});\n\t\t});\n\t\tquerystring = querystring.slice(0, -1);\n\t\tif (querystring) {\n\t\t\turl += (url.indexOf('?') > -1) ? '&' : '?';\n\t\t\turl += querystring;\n\t\t}\n\n\t\treturn url;\n\t}\n\n\t/**\n\t * Joins the given paths.\n\t * @param {string} basePath\n\t * @param {...string} ...paths Any number of paths to be joined with the base url.\n\t */\n\tstatic joinPaths(basePath, ...paths) {\n\t\tif (basePath.charAt(basePath.length - 1) === '/') {\n\t\t\tbasePath = basePath.substring(0, basePath.length - 1);\n\t\t}\n\t\tpaths = paths.map(path => path.charAt(0) === '/' ? path.substring(1) : path);\n\t\treturn [basePath].concat(paths).join('/').replace(/\\/$/, '');\n\t}\n\n\t/**\n\t * XmlHttpRequest's getAllResponseHeaders() method returns a string of\n\t * response headers according to the format described on the spec:\n\t * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.\n\t * This method parses that string into a user-friendly name/value pair\n\t * object.\n\t * @param {string} allHeaders All headers as string.\n\t * @return {!Array.<Object<string, string>>}\n\t */\n\tstatic parseResponseHeaders(allHeaders) {\n\t\tvar headers = [];\n\t\tif (!allHeaders) {\n\t\t\treturn headers;\n\t\t}\n\t\tvar pairs = allHeaders.split('\\u000d\\u000a');\n\t\tfor (var i = 0; i < pairs.length; i++) {\n\t\t\tvar index = pairs[i].indexOf('\\u003a\\u0020');\n\t\t\tif (index > 0) {\n\t\t\t\tvar name = pairs[i].substring(0, index);\n\t\t\t\tvar value = pairs[i].substring(index + 2);\n\t\t\t\theaders.push({\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: value\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn headers;\n\t}\n\n\t/**\n\t * Parses the url separating the domain and port from the path.\n\t * @param {string} url\n\t * @return {array} Array containing the url domain and path.\n\t * @protected\n\t */\n\tstatic parseUrl(url) {\n\t\tvar base;\n\t\tvar path;\n\t\tvar qs;\n\n\t\tvar domainAt = url.indexOf('//');\n\t\tif (domainAt > -1) {\n\t\t\turl = url.substring(domainAt + 2);\n\t\t}\n\n\t\tvar pathAt = url.indexOf('/');\n\t\tif (pathAt === -1) {\n\t\t\turl += '/';\n\t\t\tpathAt = url.length - 1;\n\t\t}\n\n\t\tbase = url.substring(0, pathAt);\n\t\tpath = url.substring(pathAt);\n\n\t\tvar qsAt = path.indexOf('?');\n\t\tif (qsAt > -1) {\n\t\t\tqs = path.substring(qsAt, path.length);\n\t\t\tpath = path.substring(0, qsAt);\n\t\t} else {\n\t\t\tqs = '';\n\t\t}\n\n\t\treturn [base, path, qs];\n\t}\n\n\t/**\n\t * Requests the url using XMLHttpRequest.\n\t * @param {!string} url\n\t * @param {!string} method\n\t * @param {?string} body\n\t * @param {MultiMap=} opt_headers\n\t * @param {MultiMap=} opt_params\n\t * @param {number=} opt_timeout\n\t * @param {boolean=} opt_sync\n\t * @return {Promise} Deferred ajax request.\n\t * @protected\n\t */\n\tstatic request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync) {\n\t\tvar request = new XMLHttpRequest();\n\n\t\tvar promise = new Promise(function(resolve, reject) {\n\t\t\trequest.onload = function() {\n\t\t\t\tif (request.aborted) {\n\t\t\t\t\trequest.onerror();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(request);\n\t\t\t};\n\t\t\trequest.onerror = function() {\n\t\t\t\tvar error = new Error('Request error');\n\t\t\t\terror.request = request;\n\t\t\t\treject(error);\n\t\t\t};\n\t\t}).thenCatch(function(reason) {\n\t\t\trequest.abort();\n\t\t\tthrow reason;\n\t\t}).thenAlways(function() {\n\t\t\tclearTimeout(timeout);\n\t\t});\n\n\t\tif (opt_params) {\n\t\t\turl = Ajax.addParametersToUrlQueryString(url, opt_params);\n\t\t}\n\n\t\trequest.open(method, url, !opt_sync);\n\n\t\tif (opt_headers) {\n\t\t\topt_headers.names().forEach(function(name) {\n\t\t\t\trequest.setRequestHeader(name, opt_headers.getAll(name).join(', '));\n\t\t\t});\n\t\t}\n\n\t\trequest.send(core.isDef(body) ? body : null);\n\n\t\tif (core.isDefAndNotNull(opt_timeout)) {\n\t\t\tvar timeout = setTimeout(function() {\n\t\t\t\tpromise.cancel('Request timeout');\n\t\t\t}, opt_timeout);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n}\n\nexport default Ajax;"],"sourceRoot":"/source/"}