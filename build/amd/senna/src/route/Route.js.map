{"version":3,"sources":["Route.js"],"names":["Route","path","handler","isDefAndNotNull","Error","isFunction","parsedData_","tokens","regex","isString","buildParsedData_","value","RegExp","search"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAKMA,K;;AAEL;;;;;;AAMA,iBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AAC1B,OAAI,CAAC,YAAKC,eAAL,CAAqBF,IAArB,CAAL,EAAiC;AAChC,UAAM,IAAIG,KAAJ,CAAU,2BAAV,CAAN;AACA;AACD,OAAI,CAAC,YAAKC,UAAL,CAAgBH,OAAhB,CAAL,EAA+B;AAC9B,UAAM,IAAIE,KAAJ,CAAU,kCAAV,CAAN;AACA;;AAED;;;;;;AAMA,QAAKF,OAAL,GAAeA,OAAf;;AAEA;;;;;AAKA,QAAKD,IAAL,GAAYA,IAAZ;AACA;;AAED;;;;;;;;;sCAKmB;AAClB,QAAI,CAAC,KAAKK,WAAV,EAAuB;AACtB,SAAIC,SAAS,uBAAM,KAAKN,IAAX,CAAb;AACA,SAAIO,QAAQ,yBAAQD,MAAR,CAAZ;AACA,UAAKD,WAAL,GAAmB;AAClBE,kBADkB;AAElBD;AAFkB,MAAnB;AAIA;AACD,WAAO,KAAKD,WAAZ;AACA;;;iCAQaL,I,EAAM;AACnB,QAAI,YAAKQ,QAAL,CAAc,KAAKR,IAAnB,CAAJ,EAA8B;AAC7B,YAAO,6BAAY,KAAKS,gBAAL,GAAwBH,MAApC,EAA4CN,IAA5C,CAAP;AACA;AACD,WAAO,EAAP;AACA;;;gCAMY;AACZ,WAAO,KAAKC,OAAZ;AACA;;;6BAMS;AACT,WAAO,KAAKD,IAAZ;AACA;;;+BAOWU,K,EAAO;AAClB,QAAIV,OAAO,KAAKA,IAAhB;;AAEA,QAAI,YAAKI,UAAL,CAAgBJ,IAAhB,CAAJ,EAA2B;AAC1B,YAAOA,KAAKU,KAAL,CAAP;AACA;AACD,QAAI,YAAKF,QAAL,CAAcR,IAAd,CAAJ,EAAyB;AACxBA,YAAO,KAAKS,gBAAL,GAAwBF,KAA/B;AACA;AACD,QAAIP,gBAAgBW,MAApB,EAA4B;AAC3B,YAAOD,MAAME,MAAN,CAAaZ,IAAb,IAAqB,CAAC,CAA7B;AACA;;AAED,WAAO,KAAP;AACA;;;;;;mBAIaD,K","file":"Route.js","sourcesContent":["'use strict';\n\nimport { core } from 'metal';\nimport { extractData, parse, toRegex } from 'metal-path-parser';\n\nclass Route {\n\n\t/**\n\t * Route class.\n\t * @param {!string|RegExp|Function} path\n\t * @param {!Function} handler\n\t * @constructor\n\t */\n\tconstructor(path, handler) {\n\t\tif (!core.isDefAndNotNull(path)) {\n\t\t\tthrow new Error('Route path not specified.');\n\t\t}\n\t\tif (!core.isFunction(handler)) {\n\t\t\tthrow new Error('Route handler is not a function.');\n\t\t}\n\n\t\t/**\n\t\t * Defines the handler which will execute once a URL in the application\n\t\t * matches the path.\n\t\t * @type {!Function}\n\t\t * @protected\n\t\t */\n\t\tthis.handler = handler;\n\n\t\t/**\n\t\t * Defines the path which will trigger the route handler.\n\t\t * @type {!string|RegExp|Function}\n\t\t * @protected\n\t\t */\n\t\tthis.path = path;\n\t}\n\n\t/**\n\t* Builds parsed data (regex and tokens) for this route.\n\t* @return {!Object}\n\t* @protected\n\t*/\n\tbuildParsedData_() {\n\t\tif (!this.parsedData_) {\n\t\t\tvar tokens = parse(this.path);\n\t\t\tvar regex = toRegex(tokens);\n\t\t\tthis.parsedData_ = {\n\t\t\t\tregex,\n\t\t\t\ttokens\n\t\t\t};\n\t\t}\n\t\treturn this.parsedData_;\n\t}\n\n\t/**\n\t * Extracts param data from the given path, according to this route.\n\t * @param {string} path The url path to extract params from.\n\t * @return {Object} The extracted data, if the path matches this route, or\n\t *     null otherwise.\n\t */\n\textractParams(path) {\n\t\tif (core.isString(this.path)) {\n\t\t\treturn extractData(this.buildParsedData_().tokens, path);\n\t\t}\n\t\treturn {};\n\t}\n\n\t/**\n\t * Gets the route handler.\n\t * @return {!Function}\n\t */\n\tgetHandler() {\n\t\treturn this.handler;\n\t}\n\n\t/**\n\t * Gets the route path.\n\t * @return {!string|RegExp|Function}\n\t */\n\tgetPath() {\n\t\treturn this.path;\n\t}\n\n\t/**\n \t * Matches if the router can handle the tested path.\n \t * @param {!string} value Path to test (may contain the querystring part).\n\t * @return {boolean} Returns true if matches any route.\n\t */\n\tmatchesPath(value) {\n\t\tvar path = this.path;\n\n\t\tif (core.isFunction(path)) {\n\t\t\treturn path(value);\n\t\t}\n\t\tif (core.isString(path)) {\n\t\t\tpath = this.buildParsedData_().regex;\n\t\t}\n\t\tif (path instanceof RegExp) {\n\t\t\treturn value.search(path) > -1;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nexport default Route;\n"]}