{"title":"Liferay Frontend Guidelines","githubRepo":"liferay/liferay-frontend-guidelines","googleAnalytics":"UA-37033501-5","index":{"title":"Docs","description":"Everything you need to know to get started.","content":" Frontend Guidelines Guidelines for a consistent frontend development in Liferay. Choose a Language Each one contains different sections with formatting, testing and conventions about the specific Language. ","srcFilePath":"src/pages/index.soy","id":"pages","url":"/./","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/search.soy","id":"search","url":"/search.html"},"js":{"children":{"conventions":{"title":"Conventions","description":"Set of conventions or coding standards focusing primarily on the hard-and-fast rules and leaving aside formatting concerns.","layout":"guideline","weight":1,"content":" {$page.description} Best Practices With the few exceptions listed below, JavaScript inside Liferay should follow the Google JavaScript Style Guide[1] Tooling Liferay JavaScript Style Guide should can be linted with the Liferay’s own ESLint config The preferrable way to configure ESLint for interop with different workflows and IDEs should be through a .eslintrc file. The standard configuration should look like this: // .eslintrc { \"extends\": \"liferay\", \"rules\": { // Additional, per-project rules... } } Workflow Integration Whenever possible, use npm scripts to configure a lint script to run eslint: // package.json { \"scripts\": { \"lint\": \"eslint */.js\" } } Pre-commit Hook Additionally, set up a Pre-commit Hook to ensure all files are always properly formatterd. This can be done using lint-staged and husky[2] // package.json { \"scripts\": { \"lint\": \"eslint */.js\", \"precommit\": \"lint-staged\" }, \"lint-staged\": { \"*.js\": [ \"npm run lint\", \"git add\" ] } } ","srcFilePath":"src/pages/js/conventions.md","id":"conventions","url":"/js/conventions.html"},"formatting":{"title":"Formatting","description":"Having a common style guide is valuable for a project & team but getting there is a very painful and unrewarding process.","layout":"guideline","weight":2,"content":" {$page.description} Best Practices Tooling Liferay's JavaScript formatting tool of choice is Prettier Settings The following formatting settings should be used: | Setting | Value | Description | | --- | --- | --- | | printWidth | 80 | Fit code within this line limit | | useTabs | true | Indent lines with tabs | | tabWidth | 4 | Number of spaces per tab | | singleQuote | true | Use single quotes | | trailingComma | all | Adds trailing commas wherever possible (function arguments). See tc39 proposal | | bracketSpacing | true | Controls the printing of spaces inside object literals | | parser | ‘babylon’ | Which parser to use | | semi | true | Whether to add a semicolon at the end of every line | As of Prettier v1.6.0, cosmiconfig is supported, so the preferrable way to configure it for interop with different workflows should be through a .prettierrc file. The standard configuration overwriting the conflicting Prettier's defaults looks like this // .prettierrc { \"useTabs\": true, \"tabWidth\": 4, \"singleQuote\": true, \"trailingComma\": \"all\" } Workflow Integration Whenever possible, use npm scripts to configure a format script to run prettier: // .prettierrc { \"scripts\": { \"format\": \"prettier --write */.js\" } } Pre-commit Hook Additionally, set up a Pre-commit Hook to ensure all files are always properly formatterd. This can be done using lint-staged and husky [1] // package.json { \"scripts\": { \"format\": \"prettier --write */.js\", \"precommit\": \"lint-staged\" }, \"lint-staged\": { \"*.js\": [ \"npm run format\", \"git add\" ] } } ","srcFilePath":"src/pages/js/formatting.md","id":"formatting","url":"/js/formatting.html"},"testing":{"title":"Testing","description":"How and what to test.","layout":"guideline","weight":3,"content":" {$page.description} ","srcFilePath":"src/pages/js/testing.md","id":"testing","url":"/js/testing.html"}},"title":"JavaScript","description":"JavaScript.","layout":"language","icon":"cup","weight":1,"content":"","srcFilePath":"src/pages/js/index.md","id":"js","url":"/js/","childIds":["conventions","formatting","testing"]},"jsx":{"children":{"conventions":{"title":"Conventions","description":"Set of conventions or coding standards focusing primarily on the hard-and-fast rules and leaving aside formatting concerns.","layout":"guideline","weight":1,"content":" {$page.description}","srcFilePath":"src/pages/jsx/conventions.md","id":"conventions","url":"/jsx/conventions.html"},"format":{"title":"Formatting","description":"Having a common style guide is valuable for a project & team but getting there is a very painful and unrewarding process.","layout":"guideline","weight":2,"content":" {$page.description} ","srcFilePath":"src/pages/jsx/format.md","id":"format","url":"/jsx/format.html"},"testing":{"title":"Testing","description":"How and what to test.","layout":"guideline","weight":3,"content":" {$page.description} ","srcFilePath":"src/pages/jsx/testing.md","id":"testing","url":"/jsx/testing.html"}},"title":"JSX","description":"Jsx","layout":"language","icon":"code-file","weight":2,"content":"","srcFilePath":"src/pages/jsx/index.md","id":"jsx","url":"/jsx/","childIds":["conventions","format","testing"]},"scss":{"children":{"conventions":{"title":"Conventions","description":"Set of conventions or coding standards focusing primarily on the hard-and-fast rules and leaving aside formatting concerns.","layout":"guideline","weight":1,"content":" {$page.description}","srcFilePath":"src/pages/scss/conventions.md","id":"conventions","url":"/scss/conventions.html"},"format":{"title":"Formatting","description":"Having a common style guide is valuable for a project & team but getting there is a very painful and unrewarding process.","layout":"guideline","weight":2,"content":" {$page.description} ","srcFilePath":"src/pages/scss/format.md","id":"format","url":"/scss/format.html"},"testing":{"title":"Testing","description":"How and what to test.","layout":"guideline","weight":3,"content":" {$page.description} ","srcFilePath":"src/pages/scss/testing.md","id":"testing","url":"/scss/testing.html"}},"title":"Sass","description":"Sass","layout":"language","icon":"heart-full","weight":3,"content":"","srcFilePath":"src/pages/scss/index.md","id":"scss","url":"/scss/","childIds":["conventions","format","testing"]},"soy":{"children":{"conventions":{"title":"Conventions","description":"Set of conventions or coding standards focusing primarily on the hard-and-fast rules and leaving aside formatting concerns.","layout":"guideline","weight":1,"content":" {$page.description} Best Practices Params Naming Params Private attributes: Should be named with a leading underscore (count, myName, etc.) Should use the internal() flag in the .js Will need to be declared as optional in the template (@{lb}param? name: string{rb}). Hint: A function in the template will always be optional A function that will manage an event should be named prefixed with _handle follow by the action that happens. &#123;template myTemplate&#125; {call Dropdown.render} {param events: ['selectedItemChanged': $_handleSelectedItemChanged] /} {/call} &#123;/template&#125; Declaring Params Soy has two ways of declaring parameters to a template: in it's soydoc comment or using the \\@param command. The soydoc comment style has been deprecated, so prefer the latter: &123;template myTemplate&#125; {@param name: string} Hello {$name}! &#123;/template&#125; Keep all of the parameters in a single block, sorted alphabetically, with optional parameters coming after required. Most text editors make easy work of this since it should be the default order when the lines are run through a sorting routine. &#123;namespace MyComponent&#125; /** MyComponent */ &#123;template myTemplate&#125; {@param backURL: string} {@param contactsCardTemplateTypes: ?} {@param id: string} {@param pathThemeImages: string} {@param portletNamespace: string} {@param? _editContactsCardTemplate: ?} {@param? _handleEditCard: any} {@param? _handleHideCreateCard: any} {@param? _handleShowCreateCard: any} {@param? _showCreateCardModal: bool} &#123;/template&#125; In your javascript file, make sure that all params are listed in the component's STATE declaration as well, even if it could have been omitted since it would only be referenced in the template. Also prefer using the Config helper exported by metal-state: import Component from 'metal-component'; import { Config } from 'metal-state'; /** MyComponent description. */ class MyComponent extends Component {} /** State definition. @static @type {!Object} */ MyComponent.STATE = { /** Make sure to add the required() flag if the prop does not have a ? in your template. **/ name: Config.string().required() }; export default MyComponent; When specifying types of params, try to be consistent and use the correct types: For primitives, use (string, number, etc.). Maps and Lists should use map and list. For functions, use the any type, since there is no native function type for Soy. Default values Prefer the ?: operator over the ternary (? : ), when declaring default values in your template: &123;template myTemplate&#125; /* Bad */ {isNonnull($name) ? $name : 'Foo'} /* Good */ {$name ?: 'Foo'} &#123;/template&#125; Handling attributes It is often the case that a component will need to handle adding to elements attributes given a variety of different conditions. Instead of trying to cram all of the logic onto a single line with many {lb}if{rb}checks or ternarys, use a {lb}let{rb} with kind=\"attributes\". &123;template myTemplate&#125; /* Bad */ ","srcFilePath":"src/pages/soy/conventions.md","id":"conventions","url":"/soy/conventions.html"},"formatting":{"title":"Formatting","description":"Having a common style guide is valuable for a project & team but getting there is a very painful and unrewarding process.","layout":"guideline","weight":2,"content":" {$page.description} Best Practices Empty lines An empty line should be placed after every block when next one is at the same identation level. &123;template myTemplate&#125; {msg desc=\"\"}add-fragment{/msg} ... &#123;/template&#125; Params with more than one line value should be treated as blocks and add a line break before the next one. &#123;template myTemplate&#125; {param dialogClasses: 'msb-fragment-name-editor__dialog' /} {param events: [ 'hide': $_handleModalHidden 'show': $_handleModalShow ] /} {param footer kind=\"html\"} {msg desc=\"\"}save{/msg} {/param} {param header kind=\"html\"} {msg desc=\"\"}add-fragment{/msg} {/param} &#123;/template&#125; Attributes in same line vs multiple lines If an element has more than two attributes place each one in a different line. &123;template myTemplate&#125; Title &#123;/template&#125; Tooling At the moment of this writing, there is no easy way to auto-format Closure Templates (Soy). For this reason, below you can find a set of patterns to follow when writing Soy templates. Refer to Closure Tempaltes (soy) Style for naming conventions and preferred patterns. ","srcFilePath":"src/pages/soy/formatting.md","id":"formatting","url":"/soy/formatting.html"},"testing":{"title":"Testing","description":"How and what to test.","layout":"guideline","weight":3,"content":" {$page.description} ","srcFilePath":"src/pages/soy/testing.md","id":"testing","url":"/soy/testing.html"}},"title":"Soy","description":"Soy","layout":"language","icon":"streams","weight":1,"content":"","srcFilePath":"src/pages/soy/index.md","id":"soy","url":"/soy/","childIds":["conventions","formatting","testing"]}},"childIds":["js","soy","jsx","scss","search"]}}